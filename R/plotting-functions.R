#' Boxed Labels - Modified plotrix
#'
#' @param x,y  x and y position of the centers of the labels. \code{x} can be a
#'   xy.coords list.
#' @param bg The fill color of the rectangles on which the labels are displayed
#'   (see Details).
#' @param labels Text strings.
#' @param border Whether to draw borders around the rectangles.
#' @param xpad,ypad The proportion of the rectangles to the extent of the text
#'   within.
#' @param srt Rotation of the labels. if 90 or 270 degrees, the box will be
#'   rotated 90 degrees.
#' @param cex Character expansion. See \code{text}.
#' @param adj left/right adjustment. If this is set outside the function, the
#'   box will not be aligned properly.
#' @param xlog Whether the X axis is a log axis.
#' @param ylog Whether the y axis is a log axis.
#' @param alpha.bg Numeric [0,1] controlling the transparency of the background,
#'   set to 0.5 by default.
#' @param ... additional arguments passed to \code{text}.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom graphics par strwidth strheight rect text
#' @importFrom grDevices col2rgb adjustcolor
#' @importFrom utils modifyList
#'
#' @noRd
.boxed.labels <- function(x,
                          y = NA,
                          labels,
                          bg = ifelse(match(par("bg"), "transparent", 0),
                                      "white", par("bg")
                          ),
                          border = NA,
                          xpad = 1.2,
                          ypad = 1.2,
                          srt = 0,
                          cex = 1,
                          adj = 0.5,
                          xlog = FALSE,
                          ylog = FALSE,
                          alpha.bg = 0.5, ...) {
  border <- NA
  oldpars <- par(c("cex", "xpd"))
  par(cex = cex, xpd = TRUE)
  if(.all_na(y)){
    y <- x
  }
  box.adj <- adj + (xpad - 1) * cex * (0.5 - adj)
  if (srt == 90 || srt == 270) {
    bheights <- strwidth(labels)
    theights <- bheights * (1 - box.adj)
    bheights <- bheights * box.adj
    lwidths <- rwidths <- strheight(labels) * 0.5
  }
  else {
    lwidths <- strwidth(labels)
    rwidths <- lwidths * (1 - box.adj)
    lwidths <- lwidths * box.adj
    bheights <- theights <- strheight(labels) * 0.5
  }
  args <- list(
    x = x, y = y, labels = labels, srt = srt, adj = adj,
    col = ifelse(colSums(col2rgb(bg) * c(1, 1.4, 0.6)) <
                   350, "white", "black")
  )
  args <- modifyList(args, list(...))
  if (xlog) {
    xpad <- xpad * 2
    xr <- exp(log(x) - lwidths * xpad)
    xl <- exp(log(x) + lwidths * xpad)
  }
  else {
    xr <- x - lwidths * xpad
    xl <- x + lwidths * xpad
  }
  if (ylog) {
    ypad <- ypad * 2
    yb <- exp(log(y) - bheights * ypad)
    yt <- exp(log(y) + theights * ypad)
  }
  else {
    yb <- y - bheights * ypad
    yt <- y + theights * ypad
  }
  rect(xr,
       yb,
       xl,
       yt,
       col = adjustcolor(col = bg, alpha.f = alpha.bg),
       border = border
  )
  do.call(text, args)
  par(cex = oldpars)
}

#' spread.labs from TeachingDemos
#' 
#' Used internally in cyto_plot to offset overlapping labels in y direction.
#' 
#' @param x x or y co-ordinates to spread out
#' @param mindiff minimum difference between values
#' @param maxiter maximum number of iterations
#' @param stepsize how far to move values with each iteration
#' @param min minimum bound for returned values
#' @param max maximum bound for returned values
#' 
#' @return spread co-ordinates
#' 
#' @author Greg Snow \email{538280@gmail.com}
#' 
#' @noRd
spread.labs <- function(x, 
                        mindiff, 
                        maxiter=1000, 
                        stepsize=1/10,
                        min=-Inf, 
                        max=Inf) {
  unsort <- order(order(x))
  x <- sort(x)
  df <- x[-1] - x[ -length(x) ]
  
  stp <- mindiff * stepsize
  
  i <- 1
  while( any( df < mindiff ) ) {
    tmp <- c( df < mindiff, FALSE )
    if( tmp[1] && (x[1] - stp) < min ) {  # don't move bottom set
      tmp2 <- as.logical( cumprod(tmp) )
      tmp <- tmp & !tmp2
    }
    x[ tmp ] <- x[ tmp ] - stp
    tmp <- c( FALSE, df < mindiff )
    if( tmp[length(tmp)] && (x[length(x)] + stp) > max ) { # don't move top
      tmp2 <- rev( as.logical( cumprod( rev(tmp) ) ) )
      tmp <- tmp & !tmp2
    }
    x[ tmp ] <- x[ tmp] + stp
    
    df <- x[-1] - x[-length(x)]
    i <- i + 1
    if( i > maxiter ) {
      warning("Maximum iterations reached")
      break
    }
  }
  x[unsort]
}

#' Merge overlay for merged data
#'
#' @param x flowSet data to be merged.
#' @param overlay object generated by checkOverlay flowSet method (list of
#'   flowFrame lists).
#' @param group_by pData variables of x used to merge the data. To merge all
#'   samples set group_by to "all".
#' @param display numeric [0,1] to control the percentage of events to be
#'   plotted. Specifying a value for \code{display} can substantial improve
#'   plotting speed for less powerful machines.
#'
#' @importFrom flowCore sampleFilter Subset identifier
#' @importFrom flowWorkspace sampleNames
#'
#' @noRd
.cyto_overlay_merge <- function(x,
                                overlay,
                                group_by = "all",
                                display = NULL) {
  
  # x is flowSet prior to merging
  if (!class(x)[1] %in% c("flowSet", "GatingSet") |
      length(overlay) != length(x)) {
    stop("Supply the original data prior to merging.")
  }
  
  # Extract pData
  pd <- pData(x)
  
  # Sort pd by group_by column names
  if (group_by[1] != "all") {
    pd <- pd[do.call("order", pd[group_by]), ]
  }
  
  # Find new indicies
  ind <- match(sampleNames(x), pd$name)
  ind <- ind[!is.na(ind)]
  
  # Reorder overlays based on group_by levels
  overlay <- overlay[ind]
  
  # List of group indicies - ind
  if (length(group_by) == 1 & group_by[1] == "all") {
    grps <- list(seq_len(length(x)))
  } else {
    
    # Groups
    if (length(group_by) == 1) {
      pd$mrg <- pd[, group_by]
    } else {
      pd$mrg <- do.call("paste", pd[, group_by])
    }
    
    # Get a list of indices per group
    grps <- lapply(unique(pd$mrg), function(x) {
      which(pd$mrg == x)
    })
  }
  
  # Subset overlay, merge & display
  overlay <- lapply(grps, function(x) {
    ov <- overlay[x]
    
    lapply(seq_len(length(ov[[1]])), function(x) {
      fr.lst <- lapply(ov, `[[`, x)
      
      # if same flowFrame return first only
      if (length(unique(fr.lst)) == 1 |
          length(unique(unlist(lapply(fr.lst, function(x) {
            identifier(x)
          })))) == 1) {
        fr <- fr.lst[[1]]
      } else {
        fs <- flowSet(fr.lst)
        
        fr <- as(fs, "flowFrame")
        
        if ("Original" %in% BiocGenerics::colnames(fr)) {
          fr <- suppressWarnings(
            fr[, -match("Original", BiocGenerics::colnames(fr))]
          )
        }
      }
      
      if (!is.null(display)) {
        fr <- Subset(fr, sampleFilter(size = display * BiocGenerics::nrow(fr)))
      }
      
      return(fr)
    })
  })
  
  return(overlay)
}

#' Gate 1D with overlays
#'
#' @param x flowFrame (base).
#' @param channels used in the plot.
#' @param overlay list of flowFrames to overlay.
#' @param gate gate object(s).
#' @param trans transform object used by cyto_plot_label to calculate
#'   statistics.
#' @param density_stack degree of stacking.
#' @param density_modal logical indicating whether y axis should be normalised
#'   to mode.
#' @param label_text text to use in label.
#' @param label_stat statistic to use in label.
#' @param gate_line_col gate(s) colour(s).
#' @param gate_line_width gate(s) line width(s).
#' @param gate_line_type gate(s) line type(s).
#' @param label_text_font font(s) for labels.
#' @param label_text_size text size(s) for labels.
#' @param label_text_col text colour(s) for labels.
#' @param label_box_x x co-ordinate(s) for label(s).
#' @param label_box_y y co-ordinates for label(s).
#' @param label_box_alpha transparency for label(s).
#'
#' @importFrom flowCore parameters
#'
#' @noRd
.cyto_overlay_gate <- function(x,
                               channels,
                               overlay = NA,
                               gate = NA,
                               trans = NA,
                               density_stack = 0.6,
                               density_modal = FALSE,
                               label_text = NA,
                               label_stat = "median",
                               gate_line_col = "red",
                               gate_line_width = 2.5,
                               gate_line_type = 1,
                               label_text_font = 2,
                               label_text_size = 0.8,
                               label_text_col = "black",
                               label_box_x = NA,
                               label_box_y = NA,
                               label_box_alpha = 0.6, ...) {
  
  # Check class of x
  if (!inherits(x, "flowFrame")) {
    stop("x should be a flowFrame object.")
  }
  
  # Samples
  smp <- length(overlay) + 1
  
  # Check channels
  channels <- cyto_channels_extract(
    x = x,
    channels = channels,
    plot = TRUE
  )
  
  # list of gate
  if (inherits(gate, "filters")) {
    
    # Convert to list of gate
    gate <- lapply(seq_len(length(gate)), function(x) gate[[x]])
    
  } else if (inherits(gate, "list")) {
    
  } else if (inherits(gate, "rectangleGate") |
             inherits(gate, "polygonGate") |
             inherits(gate, "ellipsoidGate")) {
    gate <- list(gate)
  }
  
  # Plot gate
  gate <- cyto_plot_gate(gate,
                 channels = channels,
                 gate_line_col = gate_line_col,
                 gate_line_width = gate_line_width,
                 gate_line_type = gate_line_type
  )
  
  # Repeat gate number of layers -
  gate <- do.call("rep", list(gate, smp))

  # Find center x co-ord for label position in each gate
  if (all(is.na(label_box_x))) {
    label_box_x <- unlist(lapply(unique(gate), function(x) {
      (unname(x@min) + unname(x@max)) / 2
    }))
  }
  label_box_x <- do.call("rep", list(label_box_x, smp))
  
  # Find y co-ord for each sample
  if (.all_na(label_box_y) & density_modal) {
    label_box_y <- unlist(lapply(rep(seq(1, smp), 
                                     length.out = length(gate), 
                                     each = length(unique(gate))), 
                                     function(x) {
      (0.5 * density_stack * 100) + ((x - 1) * density_stack * 100)
    }))
    
  # Too much computation required here - do this in cyto_plot_1d flowFrame
  }else if(.all_na(label_box_y) & !density_modal){
    stop("Need to supply y positions for labels")
  } 
  
  # List of flowFrames for cyto_plot_label
  fr.lst <- c(list(x), overlay)
  
  # Plot labels
  ind <- rep(seq_len(smp), 
             each = length(unique(gate)), 
             length.out = smp*length(unique(gate)))
  ind <- split(seq_len(smp*length(unique(gate))), ind)
  
  # Repeat arguments
  label_text <- rep(label_text, length.out = length(gate))
  label_stat <- rep(label_stat, length.out = length(gate))
  label_text_font <- rep(label_text_font, length.out = length(gate))
  label_text_size <- rep(label_text_size, length.out = length(gate))
  label_text_col <- rep(label_text_col, length.out = length(gate))
  label_box_alpha <- rep(label_box_alpha, length.out = length(gate))
  
  mapply(function(fr,x) {
      suppressMessages(cyto_plot_label(
        x = fr,
        channels = channels,
        gate = gate[x],
        trans = trans,
        text_x = label_box_x[x],
        text_y = label_box_y[x],
        text = label_text[x],
        stat = label_stat[x],
        text_font = label_text_font[x],
        text_col = label_text_col[x],
        text_size = label_text_size[x],
        box_alpha = label_box_alpha[x]
      ))
      
    }, fr.lst,
    ind)
}
