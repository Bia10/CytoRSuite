#' Compute Spillover Spreading Matrix
#'
#' \code{spillover_spread} computes the spillover spreading matrix as described
#' by Nguyen et al. (2013) using gated and compensated compensation controls
#' which include a reference universal unstained control.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}} or
#'   \code{\link[flowWorkspace:GatingSet-class]{GatingSet}}.
#' @param ... additional method-specific arguments for spillover_spread.
#'
#' @references Nguyen R, Perfetto S, Mahnke YD, Chattopadhyay P & Roederer M,
#'   (2013). Quantifying spillover spreading for comparing instrument
#'   performance and aiding in multicolor panel design. Cytometry A,
#'   83(3):306-15.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
setGeneric(
  name = "spillover_spread_compute",
  def = function(x, ...) {
    standardGeneric("spillover_spread_compute")
  }
)

#' Compute Spillover Spreading Matrix
#'
#' \code{spillover_spread} computes the spillover spreading matrix as described
#' by Nguyen et al. (2013) using gated and compensated compensation controls
#' which include a reference universal unstained control.
#'
#' @param x object of class \code{\link[flowCore:flowSet-class]{flowSet}}
#'   containing pre-gated single stain compensation controls and a universal
#'   unstained control.
#' @param axes_trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} generated by
#'   \code{estimateLogicle} to transform fluorescent channels for gating.
#'   \code{axes_trans} is required if logicle transformation has already been
#'   applied to \code{x} using estimateLogicle. \code{spillover_cspread} will
#'   automatically call \code{\link[flowCore:logicleTransform]{estimateLogicle}}
#'   internally to transform channels prior to gating, if \code{axes_trans} is
#'   supplied it will be used for the transformation instead.
#' @param channel_match name of .csv file containing the names of the samples in
#'   a column called "name" and their matching channel in a column called
#'   "channel". \code{spillover_spread} will the guide you through the channel
#'   selection process and generate a channel match file called
#'   "Compensation-Channels.csv" automatically. If you already have a complete
#'   channel_match and would like to bypass the channel selection process,
#'   simply pass the name of the channel_match to this argument (e.g.
#'   "Compensation-Channels.csv").
#' @param compensated logical indicating whether the supplied compensation
#'   controls have been compensated. Compensation controls must be compensated
#'   prior tro calculation of spillover spreading matrix. If \code{compensated}
#'   is set to FALSE, the compensation controls will be compensated internally
#'   using the supplied \code{spillover}. If no spillover matrix is supplied
#'   \code{spillover_spread_compute} will look for a "Spillover-Matrix.csv" file
#'   or as a last resort use the spillover matrix attached to compensation
#'   controls.
#' @param spillover name of the output spillover matrix csv file to be used
#'   internally to compensate the compensation controls. If no spillover matrix
#'   is supplied \code{spillover_spread_compute} will look for a
#'   "Spillover-Matrix.csv" file or as a last resort use the spillover matrix
#'   attached to compensation controls.
#' @param spillover_spread name of the csv file to which the spillover spreading
#'   matrix will be saved, set to \code{"Spillover-Spread-Matrix.csv"} by
#'   default.
#' @param ... additional arguments passed to
#'   \code{\link{cyto_plot,flowFrame-method}}.
#'
#' @return spillover spreading matrix object, write spillover spreading matrix
#'   to csv file called \code{"Spillover-Spread-Matrix.csv"} and plot the
#'   resulting matrix as a heatmap.
#'
#' @references Nguyen R, Perfetto S, Mahnke YD, Chattopadhyay P & Roederer M,
#'   (2013). Quantifying spillover spreading for comparing instrument
#'   performance and aiding in multicolor panel design. Cytometry A,
#'   83(3):306-15.
#'
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#'
#' @export
setMethod(
  spillover_spread_compute,
  signature = "flowSet",
  definition = function(x,
                        axes_trans = NULL,
                        channel_match = NULL,
                        compensated = FALSE,
                        spillover = NULL,
                        spillover_spread = "Spillover-Spread-Matrix.csv",
                        ...) {
    
    # Assign x to fs
    fs <- x
    
    # Compensate samples
    if(!compensated){
      
      # Extract spillover matrix
      if(!is.null(spillover)){
        if(getOption("CytoRSuite_wd_check")){
          if(!.file_wd_check(spillover)){
            stop(paste(spillover, "does not exist in this working directory."))
          }
        }
        spill <- read.csv(spillover, header = TRUE, row.names = 1)
        colnames(spill) <- rownames(spill)
      }else{
        # Check if Spillover-Matrix.csv exists in wd
        if(length(grep("Spillover-Matrix.csv", list.files())) != 0){
          message("Using file 'Spillover-Matrix.csv' to compensate samples.")
          spill <- read.csv(list.files()[grep("Spillover-Matrix.csv",
                                              list.files())[1]],
                            header = TRUE, row.names = 1)
          colnames(spill) <- rownames(spill)
        }else{
          spill <- fs[[1]]@description$SPILL
        }
      }
      
      # Apply compensation
      if (inherits(fs, "ncdfFlowSet")) {
        fs <- suppressMessages(ncfsApply(fs, function(fr) {
          compensate(fr, spill)
        }))
      } else if (inherits(fs, "flowSet")) {
        fs <- suppressMessages(fsApply(fs, function(fr) {
          compensate(fr, spill)
        }))
      }
    }
    
    # Extract pData information
    pd <- pData(fs)
    
    # Extract fluorescent channels
    channels <- cyto_fluor_channels(fs)
    
    # Select a fluorescent channel for each compensation control
    if (is.null(channel_match)) {
      pd$channel <- paste(cyto_channel_select(fs))
      write.csv(pd, "Compensation-Channels.csv", row.names = FALSE)
    } else {
      if (inherits(channel_match, "data.frame") |
          inherits(channel_match, "matrix") |
          inherits(channel_match, "tibble")) {
        if (!all(c("name", "channel") %in% colnames(channel_match))) {
          stop("channel_match should contains columns 'name' and 'channel'.")
        }
        cm <- channel_match
        chans <- cm$channel[match(sampleNames(fs), rownames(cm))]
        pd$channel <- paste(chans)
      } else {
        if (getOption("CytoRSuite_wd_check") == TRUE) {
          if (.file_wd_check(channel_match)) {
            cm <- read.csv(channel_match, header = TRUE, row.names = 1)
            chans <- cm$channel[match(sampleNames(fs), row.names(cm))]
            pd$channel <- paste(chans)
          } else {
            stop(paste(channel_match, "is not in this working directory."))
          }
        } else {
          cm <- read.csv(channel_match, header = TRUE, row.names = 1)
          chans <- cm$channel[match(sampleNames(fs), row.names(cm))]
          pd$channel <- paste(chans)
        }
      }
    }
    
    # Merge files for use with estimateLogicle
    fr <- as(fs, "flowFrame")
    
    # Extract summary statistics
    sm <- pData(parameters(fs[[1]]))
    
    # Get complete transformList object
    axes_trans <- .getCompleteTransList(fr, axes_trans)
    
    # Get transformed data - all fluorescent channels transformed
    fs <- .getTransformedData(fs, axes_trans)
    
    # Extract unstained control based on selected channels in pData(fs)
    NIL <- fs[[match("Unstained", pd$channel)]]
    fs <- fs[-match("Unstained", pd$channel)]
    
    # Names
    nms <- sampleNames(fs)
    
    # Samples
    smp <- length(fs)
    
    # Remove NIL from pd
    pd <- pd[!pd$channel == "Unstained", ]
    
    # Gate positive populations
    pops <- lapply(seq(1, smp, 1), function(x) {
      
      # Extract flowFrame
      fr <- fs[[x]]
      
      # Channel
      chan <- pd$channel[x]
      
      # Plot
      if (getOption("CytoRSuite_interact") == TRUE) {
        cyto_plot(NIL,
                  channels = chan,
                  overlay = fr,
                  density_stack = 0,
                  axes_trans = axes_trans,
                  popup = TRUE,
                  density_fill = c("red", "dodgerblue"),
                  legend = FALSE,
                  density_fill_alpha = 0.6,
                  title = nms[x], ...
        )
      } else {
        cyto_plot(NIL,
                  channels = chan,
                  overlay = fr,
                  density_stack = 0,
                  axes_trans = axes_trans,
                  density_fill = c("red", "dodgerblue"),
                  legend = FALSE,
                  density_fill_alpha = 0.6,
                  title = nms[x], ...
        )
      }
      
      # Call gate_draw on each flowFrame using interval gate on selected channel
      if (getOption("CytoRSuite_interact") == TRUE) {
        gt <- gate_draw(
          x = fr,
          alias = paste(chan, "+"),
          channels = chan,
          type = "interval",
          density_smooth = 1.5,
          plot = FALSE
        )
        fr <- Subset(fr, gt[[1]])
      }
      
      return(fr)
    })
    names(pops) <- nms
    pops <- flowSet(pops)
    
    # Inverse logicle transformation
    inv <- cyto_trans_check(axes_trans, inverse = TRUE)
    pops <- suppressMessages(transform(pops, inv))
    NIL <- suppressMessages(transform(NIL, inv))
    
    # Calculate 50th & 80th percentile in all channels for NIL
    NIL_50 <- unlist(lapply(channels, function(channel){
      quantile(exprs(NIL)[,channel], 0.5)
    }))
    names(NIL_50) <- channels
    
    NIL_84 <- unlist(lapply(channels, function(channel){
      quantile(exprs(NIL)[,channel], 0.84)
    }))
    names(NIL_84) <- channels
    
    # Combine into a list - NIL_stats
    NIL_stats <- list("50%" = NIL_50, "84%" = NIL_84)
    
    # Calculate 50th and 84th percentile in all channels for each control
    POS_stats <- lapply(seq_len(length(pops)), function(x){
      
      # Calculate 50th & 80th percentile in all channels
      POP_50 <- unlist(lapply(channels, function(channel){
        quantile(exprs(pops[[x]])[,channel], 0.5)
      }))
      names(POP_50) <- channels
      
      POP_84 <- unlist(lapply(channels, function(channel){
        quantile(exprs(pops[[x]])[,channel], 0.84)
      }))
      names(POP_84) <- channels
      
      # Combine into a list - NIL_stats
      POP_stats <- list("50%" = POP_50, "84%" = POP_84)
      
      return(POP_stats)
      
    })
    names(POS_stats) <- pd$channel
    
    # Calculate POS signal in other detectors
    POS_signal <- lapply(seq_len(length(POS_stats)), function(x){
      
      POS_stats[[x]][[2]] - POS_stats[[x]][[1]]
      
    })
    names(POS_signal) <- pd$channel
    
    # Calculate NIL signal in other detectors
    NIL_signal <- NIL_stats[[2]] - NIL_stats[[1]] 
    names(NIL_signal) <- pd$channel
    
    # Difference
    DIFF <- lapply(seq_len(length(POS_signal)), function(x){
      sqrt(POS_signal[[x]]^2) - sqrt(NIL_signal^2)
    })
    names(DIFF) <- pd$channel
    
    # Brightness
    BRGHT <- lapply(seq_len(length(POS_signal)), function(x){
      POS_signal[[x]][match(names(POS_signal[x]), channels)] - 
        NIL_stats[[1]][match(names(POS_signal[x]),channels)]
    })
    names(BRGHT) <- pd$channel
    
    # SSM
    SSM <- lapply(DIFF, function(x){
      
      x/(sqrt(BRGHT[[1]]))
      
    })
    
    # Make matrix
    SSM <- do.call("rbind", SSM)
    
    # Replace diagonal with NA
    lapply(seq(1, nrow(SSM), 1), function(x) {
      SSM[x, match(rownames(SSM)[x], colnames(SSM))] <<- NA
    })
    
    # Sort SSM by column names
    ind <- na.omit(match(colnames(SSM), rownames(SSM)))
    SSM <- SSM[ind, ]
    
    # Turn off pop-up graphics device
    graphics.off()
    dev.new()
    
    # Heatmap label size
    ylab_width <- max(nchar(rownames(SSM))) * 0.02
    xlab_width <- max(nchar(colnames(SSM))) * 0.04               
    
    # Plot heatmap
    superheat::superheat(SSM,
                         title = "Spillover Spreading Matrix \n",
                         title.size = 6,
                         title.alignment = "center",
                         bottom.label.text.angle = 90,
                         left.label.size = ylab_width,
                         bottom.label.size = xlab_width,
                         left.label.text.alignment = "center",
                         legend.height = 0.2,
                         legend.vspace = 0.2,
                         row.title = "Fluorochrome \n",
                         row.title.size = 6,
                         heat.na.col = "white",
                         heat.pal =)
    
    # Write to csv file
    if (!inherits(spillover_spread, "character")) {
      stop("'spillover_spread' should be the name of a csv file.")
    } else {
      if (!file_ext(spillover_spread) == "csv") {
        paste0(spillover_spread, ".csv")
      }
      write.csv(SSM, spillover_spread)
    }
    
    return(SSM)
  }
)