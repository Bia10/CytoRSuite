#' Add boxed text labels to cyto_plot
#'
#' \code{cyto_plot_label} takes on a \code{flowFrame} object, population name
#' \code{text}, \code{channels} and a gate object to construct a text label for
#' the plot with the population name and frequency. In the absence of a gate,
#' users can manually specify the label position using the \code{text_x} and
#' \code{text_y} arguments.
#'
#' @param x object of class \code{"flowFrame"}.
#' @param gate object of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}},
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}},
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}, \code{"list"} or
#'   \code{\link[flowCore:filters-class]{filters}}.
#' @param trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param text character string to include in the label above the statistic
#'   (e.g. population name(s)).
#' @param stat indicates the type of statistic to include in the label, can be
#'   either code{"count"}, \code{"median"}, \code{"mean"}, \code{"mode"},
#'   \code{"geo mean"} or \code{"CV"}. \code{stat} is set to \code{"median"} by
#'   default. Statistics for fluorescent intensity are calculated for the entire
#'   distribution. Only count and percent statistics are supported for 2D plots.
#' @param text_x vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_y vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_font integer [1,2,3,4] passed to \code{text} to alter the font,
#'   set to \code{2} by default for a bold font.
#' @param text_size numeric character expansion used to control the size of the
#'   text in the labels, set to \code{0.8} by default. See \code{?text} for
#'   details.
#' @param text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param box_alpha numeric [0,1] controls the transparency of the background,
#'   set to \code{0.6} by default.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for mode
#'   calculation.
#'
#' @return add a boxed text label to an existing plot.
#'
#' @importFrom flowCore Subset parameters
#' 
#' @examples 
#' #' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#'
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#'
#' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "T Cells",
#'   channels = c("Alexa Fluor 488-A", "Alexa Fluor 700-A")
#' )
#'
#' # Labels without gates - position using text_x and text_y
#' cyto_plot_label(getData(gs, "T Cells")[[4]],
#'   gate = NULL,
#'   channels = c("Alexa Fluor 488-A", "Alexa Fluor 700-A"),
#'   trans = trans,
#'   text = c("CD4 T Cells", "CD8 T Cells"),
#'   text_x = c(3.1, 1),
#'   text_y = c(-0.2, 3.2)
#' )
#' 
#' #' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   channels = "7-AAD-A"
#' )
#'
#' # CD69+ CD4 T Cells gate
#' gt <- getGate(gs, "CD69+ CD4 T Cells")[[1]]
#' cyto_plot_gate(gt,
#'   channels = "7-AAD-A"
#' )
#'
#' # Labels
#' cyto_plot_label(getData(gs, "CD4 T Cells")[[4]],
#'   gate = gt,
#'   trans = trans,
#'   channels = "7-AAD-A",
#'   text = c("CD69+"),
#'   stat = "freq",
#'   text_col = "blue"
#' )
#' 
#' #' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "root",
#'   channels = c("FSC-A", "SSC-A")
#' )
#' 
#' # Cells gate
#' gt <- getGate(gs, "Cells")[[1]]
#' cyto_plot_gate(gt,
#'   channels = c("FSC-A", "SSC-A")
#' )
#' 
#' # Labels
#' cyto_plot_label(getData(gs, "root")[[4]],
#'   gate = gt,
#'   trans = trans,
#'   channels = c("FSC-A", "SSC-A"),
#'   text = "Cells",
#'   stat = "freq",
#'   text_col = "magenta",
#'   text_size = 1.2
#' )
#' 
#' #' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "Live Cells",
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#' 
#' # T Cells gate
#' gt <- getGate(gs, "T Cells")[[1]]
#' cyto_plot_gate(gt,
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#' 
#' # Labels
#' cyto_plot_label(getData(gs, "Live Cells")[[4]],
#'   gate = gt,
#'   trans = trans,
#'   channels = c("APC-Cy7-A", "PE-A"),
#'   text = "T Cells",
#'   stat = "count",
#'   text_col = "magenta",
#'   text_size = 1.2,
#'   box_alpha = 1
#' )
#' 
#' #' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "Live Cells",
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#'
#' # T Cells & Dendritic Cells gates
#' gts <- list(getGate(gs, "T Cells")[[1]], getGate(gs, "Dendritic Cells")[[1]])
#' cyto_plot_gate(gts,
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#'
#' # Labels
#' cyto_plot_label(getData(gs, "Live Cells")[[4]],
#'   gate = gts,
#'   trans = trans,
#'   channels = c("APC-Cy7-A", "PE-A"),
#'   text = c("T Cells", "Dendritic Cells"),
#'   stat = "count",
#'   text_col = c("magenta", "purple"),
#'   text_size = 1.2,
#'   box_alpha = 1
#' )
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @export
cyto_plot_label <- function(x, gate, ...){
  UseMethod("cyto_plot_label", gate)
}

#' @rdname cyto_plot_label
#' @export
cyto_plot_label.NULL <- function(x,
                                gate,
                                trans = NA,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6,
                                density_smooth = 1.5) {
            
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(!.all_na(stat)){
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Missing transList
            if (stat %in% c(
              "median",
              "mode",
              "mean",
              "geo mean",
              "CV"
            )) {
              if (is.null(cyto_trans_check(trans))) {
                stop(
                  paste("Supply transformList/transformerList to calculate", stat, ".")
                )
              }
            }
            
            # Stats not supported in 2D
            if (length(channels) == 2 &
                stat %in% c(
                  "mean",
                  "median",
                  "mode",
                  "geo mean",
                  "freq",
                  "CV"
                )) {
              stop("Only count is supported for 2D plots without gates.")
            }
            
            # Missing text
            if (.all_na(text) & !.all_na(stat)) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistics
            if (!.all_na(stat)) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(fr)
              } else if (stat == "median") {
                fr <- .getRawData(x = fr, trans)
                st <- median(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "mean") {
                fr <- .getRawData(x = fr, trans)
                st <- mean(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "mode") {
                fr <- .getRawData(x = fr, trans)
                d <- density(flowCore::exprs(fr)[, channels], adjust = density_smooth)
                st <- d$x[d$y == max(d$y)]
                st <- round(st, 2)
              } else if (stat == "geo mean") {
                st <- mean(flowCore::exprs(fr)[, channels])
                inv <- cyto_trans_check(trans, inverse = TRUE)
                st <- inv@transforms[[channels]]@f(st)
                st <- round(st, 2)
              } else if (stat == "CV"){
                fr <- .getRawData(x = fr, trans)
                fr.exprs <- exprs(fr)
                md <- median(fr.exprs[,channels])
                rSD <- median(abs(fr.exprs[,channels] - md))*1.4826
                st <- rSD/md
                st <- sprintf("%.2f %%", st*100)
              }
            }
            
            # Plot Limits
            xmin <- par("usr")[1]
            xmax <- par("usr")[2]
            ymin <- par("usr")[3]
            ymax <- par("usr")[4]
            
            # Label position - x - defaults to 3/4
            if (.all_na(text_x)) {
              text_x <- xmin + (xmax - xmin) * 0.75
            }
            
            # Label position - y - defaults to 1/2
            if (.all_na(text_y)) {
              text_y <- c(ymin + ymax) / 2
            }
            
            # Add labels
            if (!.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!.all_na(text) & .all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }

#' @rdname cyto_plot_label
#' @export
cyto_plot_label.rectangleGate <- function(x,
                                gate,
                                trans = NA,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6,
                                density_smooth = 1.5) {
  
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(!.all_na(stat)) {
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Only count and percent supported in 2D
            if (length(channels) == 2 & !stat %in% c("count", "freq")) {
              stop("Only count and percent statistics are supported in 2D plots.")
            }
            
            # Missing transList
            if (stat %in% c("median", "mode", "mean", "geo mean")) {
              if (is.null(cyto_trans_check(trans))) {
                stop(
                  paste("Supply transformList/transformerList to calculate", stat, ".")
                )
              }
            }
            
            # 2D gate in 1D plot
            if (length(channels) == 1 & length(parameters(gate)) == 2) {
              gate <- gate[channels]
            }
            
            # Missing text
            if (.all_na(text) & !.all_na(stat)) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistics
            if (!.all_na(stat)) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(flowCore::Subset(fr, gate))
              } else if (stat == "freq") {
                
                # Total events
                events <- BiocGenerics::nrow(fr)
                
                # Population events - percentages
                cnt <- BiocGenerics::nrow(flowCore::Subset(fr, gate))
                prcnt <- round(cnt / events, 4)
                st <- sprintf("%.2f %%", 100 * prcnt)
              } else if (stat == "mean") {
                fr <- .getRawData(x = fr, trans)
                st <- mean(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "median") {
                fr <- .getRawData(x = fr, trans)
                st <- median(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "mode") {
                fr <- .getRawData(x = fr, trans)
                d <- density(flowCore::exprs(fr)[, channels], adjust = density_smooth)
                st <- d$x[d$y == max(d$y)]
                st <- round(st, 2)
              } else if (stat == "geo mean") {
                st <- mean(flowCore::exprs(fr)[, channels])
                inv <- cyto_trans_check(trans, inverse = TRUE)
                st <- inv@transforms[[channels]]@f(st)
                st <- round(st, 2)
              } else if (stat == "CV"){
                fr <- .getRawData(x = fr, trans)
                fr.exprs <- exprs(fr)
                md <- median(fr.exprs[,channels])
                rSD <- median(abs(fr.exprs[,channels] - md))*1.4826
                st <- rSD/md
                st <- sprintf("%.2f %%", st*100)
              }
            }
            
            # 1D gate plotted in 2D
            if (length(channels) == 2 & length(parameters(gate)) == 1) {
              rg <- matrix(c(as.numeric(gate@min), as.numeric(gate@max), -Inf, Inf),
                           ncol = 2, nrow = 2
              )
              colnames(rg) <- c(
                as.vector(parameters(gate)),
                channels[!channels == as.vector(parameters(gate))]
              )
              rownames(rg) <- c("min", "max")
              gate <- rectangleGate(.gate = rg)
            }
            
            # Gate channels
            chans <- as.vector(parameters(gate))
            
            # Plot limits
            xmin <- par("usr")[1]
            xmax <- par("usr")[2]
            ymin <- par("usr")[3]
            ymax <- par("usr")[4]
            
            # 1D gate supplied
            if (length(chans) == 1) {
              if (length(channels) == 1) {
                if (!channels == chans) {
                  stop("Supplied channel does not match that of the supplied gate.")
                } else if (channels == chans) {
                  if (.all_na(text_x)) {
                    xmin <- gate@min
                    xmax <- gate@max
                    
                    if (is.infinite(xmin)) {
                      xmin <- par("usr")[1]
                    }
                    if (is.infinite(xmax)) {
                      xmax <- par("usr")[2]
                    }
                  }
                }
              } else if (length(channels) == 2) {
                if (!chans %in% channels) {
                  stop("Supplied channels do not match that of the supplied gate.")
                } else if (chans %in% channels) {
                  if (.all_na(text_x)) {
                    xmin <- gate@min[channels[1]]
                    xmax <- gate@max[channels[1]]
                    
                    if (is.infinite(xmin)) {
                      xmin <- par("usr")[1]
                    }
                    
                    if (is.infinite(xmax)) {
                      xmax <- par("usr")[2]
                    }
                  }
                  
                  if (.all_na(text_y)) {
                    ymin <- gate@min[channels[2]]
                    ymax <- gate@max[channels[2]]
                    
                    if (is.infinite(ymin)) {
                      ymin <- par("usr")[3]
                    }
                    
                    if (is.infinite(ymax)) {
                      ymax <- par("usr")[4]
                    }
                  }
                }
              }
              
              # 2D gate supplied
            } else if (length(chans) == 2) {
              if (!all(chans %in% channels)) {
                stop("Supplied channels do not match that of the supplied gate.")
              } else if (all(chans %in% channels)) {
                if (.all_na(text_x)) {
                  xmin <- gate@min[channels[1]]
                  xmax <- gate@max[channels[1]]
                  
                  if (is.infinite(xmin)) {
                    xmin <- par("usr")[1]
                  }
                  
                  if (is.infinite(xmax)) {
                    xmax <- par("usr")[2]
                  }
                }
                
                if (.all_na(text_y)) {
                  ymin <- gate@min[channels[2]]
                  ymax <- gate@max[channels[2]]
                  
                  if (is.infinite(ymin)) {
                    ymin <- par("usr")[3]
                  }
                  
                  if (is.infinite(ymax)) {
                    ymax <- par("usr")[4]
                  }
                }
              }
            }
            
            # Label position - x - defaults to 3/4
            if (.all_na(text_x)) {
              text_x <- c(xmin + xmax) / 2
            }
            
            # Label position - y - defaults to 1/2
            if (.all_na(text_y)) {
              text_y <- c(ymin + ymax) / 2
            }
            
            # Add labels
            if (!.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!.all_na(text) & .all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }

#' @rdname cyto_plot_label
#' @export
cyto_plot_label.polygonGate <- function(x,
                                gate,
                                channels,
                                trans = NA,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(!.all_na(stat)){
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Only count and percent supported
            if (!stat %in% c("count", "freq")) {
              stop("Only 'count' and 'percent' are supported for gated 2D plots.")
            }
            
            # Missing text
            if (.all_na(text) & !.all_na(stat)) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistic
            if (!.all_na(stat)) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(flowCore::Subset(fr, gate))
              } else if (stat == "freq") {
                # Total events
                events <- nrow(fr)
                
                # Population events - percentages
                cnt <- BiocGenerics::nrow(flowCore::Subset(fr, gate))
                prcnt <- round(cnt / events, 4)
                st <- sprintf("%.2f %%", 100 * prcnt)
              }
            }
            
            # Check supplied channels & gate channels
            chans <- parameters(gate)
            
            # Check gate parameters against channels
            if (!all(chans %in% channels)) {
              stop("Supplied channels do not match that of the supplied gate.")
            }
            
            # Label position - x
            if (.all_na(text_x)) {
              text_x <- sum(gate@boundaries[, channels[1]]) / nrow(gate@boundaries)
            }
            
            # Label position - y
            if (.all_na(text_y)) {
              text_y <- sum(gate@boundaries[, channels[2]]) / nrow(gate@boundaries)
            }
            
            # Add labels
            if (!.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!.all_na(text) & .all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }

#' @rdname cyto_plot_label
#' @export
cyto_plot_label.ellipsoidGate <- function(x,
                                gate,
                                channels,
                                trans = NA,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(!.all_na(stat)){
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Only count and percent supported
            if (!stat %in% c("count", "freq")) {
              stop("Only 'count' and 'percent' are supported for gated 2D plots.")
            }
            
            # Missing text
            if (.all_na(text) & !.all_na(stat)) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistic
            if (!.all_na(stat)) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(flowCore::Subset(fr, gate))
              } else if (stat == "freq") {
                # Total events
                events <- nrow(fr)
                
                # Population events - percentages
                cnt <- BiocGenerics::nrow(flowCore::Subset(fr, gate))
                prcnt <- round(cnt / events, 4)
                st <- sprintf("%.2f %%", 100 * prcnt)
              }
            }
            
            # Check supplied channels & gate channels
            chans <- parameters(gate)
            
            # Check gate parameters against channels
            if (!all(chans %in% channels)) {
              stop("Supplied channels do not match that of the supplied gate.")
            }
            
            # Label position - x
            if (.all_na(text_x)) {
              text_x <- gate@mean[channels[1]]
            }
            
            # Label position - y
            if (.all_na(text_y)) {
              text_y <- gate@mean[channels[2]]
            }
            
            # Add labels
            if (!.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!.all_na(text) & .all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (.all_na(text) & !.all_na(stat)) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }

#' @rdname cyto_plot_label
#' @export
cyto_plot_label.list <- function(x,
                                gate,
                                trans = NA,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Convert filters object in list to list of gate
            gate <- unlist(gate)
            
            # Get adjusted label coords to prevent overlap
            coords <- .cyto_plot_label_offset(x,
                                              gate,
                                              channels,
                                              text,
                                              stat,
                                              text_size)

            # Replace x coords if text_x is NA
            if(.all_na(text_x)){
              text_x <- coords[["x"]]
            }
            
            # Replace y coords if text_y is NA
            if(.all_na(text_y)){
              text_y <- coords[["y"]]
            }
            
            # Make calls to cyto_plot_label
            invisible(
              mapply(
                function(gate,
                         text,
                         stat,
                         text_x,
                         text_y,
                         text_font,
                         text_col,
                         text_size,
                         box_alpha) {
                  cyto_plot_label(
                    x = x,
                    trans = trans,
                    gate = gate,
                    channels = channels,
                    text = text,
                    stat = stat,
                    text_x = text_x,
                    text_y = text_y,
                    text_font = text_font,
                    text_col = text_col,
                    text_size = text_size,
                    box_alpha = box_alpha
                  )
                }, gate,
                text, 
                stat,
                text_x,
                text_y,
                text_font,
                text_col,
                text_size,
                box_alpha
              )
            )
          }

#' @rdname cyto_plot_label
#' @export
cyto_plot_label.filters <- function(x,
                                gate,
                                trans = NA,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Convert gate to a list of gate
            gate <- unlist(gate)
            
            # Make calls to cyto_plot_label list method
            cyto_plot_label(
              x = x,
              trans = trans,
              gate = gate,
              channels = channels,
              text = text,
              stat = stat,
              text_x = text_x,
              text_y = text_y,
              text_font = text_font,
              text_col = text_col,
              text_size = text_size,
              box_alpha = box_alpha
            )
            
    }

#' Position Labels to Prevent Overlap
#'
#' @param x list of gate objects to be labelled.
#' @param channels names of channel(s) used to construct the plot.
#' @param label_text vector of character strings to use in labels.
#' @param label_text_size vector of integers for character expansion.
#'
#' @return list containing adjusted x and y coordinates for labels if any
#'   overlap is detected.
#'   
#' @importFrom stats na.omit
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @noRd
.cyto_plot_label_offset <- function(fr,
                                    x, 
                                    channels,
                                    label_text,
                                    label_stat,
                                    label_text_size) {
  
  # Invalid gate objects
  if(!inherits(x, "list")){
    stop("'x' should be a list of gate objects.")
  }
  
  # Assign x to gts
  gts <- x
  
  # Valid gate objects
  typs <- c("filters","rectangleGate","polygonGate","ellipsoidGate")
  
  # Convert gate object to list of gate
  if(inherits(gts,"list")){
    if(!all(unlist(lapply(gts, "class")) %in% typs)){
      stop("'x' does not contain a list of valid gate objects.")
    }
  }
  
  # Plot limits
  xmin <- par("usr")[1]
  xmax <- par("usr")[2]
  ymin <- par("usr")[3]
  ymax <- par("usr")[4]
  
  xrange <- xmax - xmin
  yrange <- ymax - ymin
  
  # Co-ordinates for gate centers
  coords <- lapply(gts, function(gt){
    
    if(inherits(gt, "rectangleGate")){
      
      # Gate channel(s)
      chans <- parameters(gt)
      
      if(length(channels) == 1 & length(chans) == 1){
        
        xmin <- gt@min
        xmax <- gt@max
        ymin <- ymin
        ymax <- ymax
        
      }else if(length(channels) == 1 & length(chans) == 2){
        
        xmin <- gt@min[channels[1]]
        xmax <- gt@max[channels[1]]
        ymin <- ymin
        ymax <- ymax
        
      }else if(length(channels) == 2 & length(chans) == 1){
        
        # Gate has xcoords
        if(chans == channels[1]){
          
          xmin <- gt@min
          xmax <- gt@max
          ymin <- ymin
          ymax <- ymax
          
        # Gate has ycoords
        }else if(chans == channels[2]){
          
          xmin <- xmin
          xmax <- xmax
          ymin <- gt@min
          ymax <- gt@max
          
        }
        
      }else if(length(channels) == 2 & length(chans) == 2){
        
        xmin <- gt@min[channels[1]]
        xmax <- gt@max[channels[1]]
        ymin <- gt@min[channels[2]]
        ymax <- gt@max[channels[2]]
        
      }
      coords <- c((xmin+xmax)/2, (ymin+ymax)/2)
      
    }else if(inherits(gt, "polygonGate")){
      
      coords <- c(sum(gt@boundaries[, channels[1]]) / nrow(gt@boundaries),
                  sum(gt@boundaries[, channels[2]]) / nrow(gt@boundaries))
      
    }else if(inherits(gt, "ellipsoidGate")){
      
      coords <- c(gt@mean[channels[1]], gt@mean[channels[2]])
      
    }
    return(coords)
    
  })
  coords <- do.call("rbind", coords)
  colnames(coords) <- c("x", "y")
  
  # Repeat label_text_size
  label_text_size <- rep(label_text_size, length.out = length(gts))
  
  # Repeat label_stat
  label_stat <- rep(label_stat, length.out = length(gts))
  
  # Calculate label co-ordinates
  label_coords <- lapply(seq_len(length(gts)), function(x){
    
    .cyto_plot_label_coords(label_box_x = coords[,"x"][x],
                            label_box_y = coords[,"y"][x],
                            label_text = label_text[x], 
                            label_stat = label_stat[x],
                            label_text_size = label_text_size[x])
    
  })
  
  # Check if any labels will be overlapping and offset coords
  if(any(na.omit(unlist(.cyto_plot_label_overlap(label_coords))))){
  
    
    if(all(!is.na(label_stat))){
      label_text <- paste(label_text, "\n")
    }
    
    # Use spread.labs TeachingDemos to offset y values
    label_height <- max(label_coords[[1]][,"y"]) - 
                    min(label_coords[[1]][,"y"])
    label_height <- label_height + 0.18*label_height
    coords[,"y"] <- spread.labs(coords[,"y"],
                           mindiff = label_height,
                           min = ymin + 0.05*yrange,
                           max = ymax - 0.05*yrange)
    
  }
  
  # Return a list of adjusted label positions
  coords <- list(coords[,"x"], coords[,"y"])
  names(coords) <- c("x","y")
  
  return(coords)

}

#' Dimensions of Labels
#' 
#' @param label_text character string to include in label.
#' 
#' @importFrom graphics strwidth strheight
#' 
#' @return upper left and bottom right x and y co-ordinates of labels
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @noRd
.cyto_plot_label_coords <- function(label_box_x,
                               label_box_y = NA,
                               label_text,
                               label_stat = NA,
                               bg = ifelse(match(par("bg"), "transparent", 0),
                                           "white", par("bg")
                               ),
                               xpad = 1.2,
                               ypad = 1.2,
                               label_text_size = 1,
                               adj = 0.5,
                               alpha.bg = 0.5, ...){
  
  # Get parameters for reset after calculation
  cex_reset <- par("cex")
  xpd_reset <- par("xpd")
  
  par(cex = label_text_size)
  par(xpd = TRUE)
  
  if(all(is.na(label_box_y))){
    label_box_y <- label_box_x
  }
  box.adj <- adj + (xpad - 1) * label_text_size * (0.5 - adj)
  
  # Rectangle dimensions
  lwidths <- strwidth(label_text)
  rwidths <- lwidths * (1 - box.adj)
  lwidths <- lwidths * box.adj
  bheights <- theights <- strheight(label_text) * 0.5

  # Rectangle co-ordinates
  xr <- label_box_x - lwidths * xpad
  xl <- label_box_x + lwidths * xpad
  
  # y co-ordinates must make space for label_stat
  if(is.na(label_stat)){
    
    yb <- label_box_y - bheights * ypad
    yt <- label_box_y + theights * ypad
    
  }else {
    
    yb <- label_box_y - bheights * ypad * 2
    yt <- label_box_y + theights * ypad * 2
    
  }
  
  # Return top left then bottom right co-ordinates
  coords <- matrix(c(min(c(xl,xr)),
                     max(c(yb,yt)),
                     max(c(xl,xr)),
                     min(c(yb,yt))),
                   ncol = 2,
                   byrow = TRUE)
  colnames(coords) <- c("x","y")

  # Reset par(cex)
  par(cex = cex_reset)
  par(xpd = xpd_reset)
  
  return(coords)
  
}

#' Check if any cyto_plot labels overlap
#' 
#' @param x list containing the x and y coordinates defining rectangles of plot
#' labels
#' 
#' @return list of length x. Each element compares the label to all others and 
#' returns TRUE is any overlap is detected. NA is returned when comparing the
#' same label co-ordinates.
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @noRd
.cyto_plot_label_overlap <- function(x) {
  
  # For each rectangle in x
  overlaps <- lapply(seq_len(length(x)), function(y){
    
    # Check if other rectangles overlap
    unlist(lapply(seq_len(length(x)), function(z){
      
      # Co-ordinates of reference label
      x1 <- x[[y]][,"x"]
      y1 <- x[[y]][,"y"]
        
      # Co-ordinates of comparison label
      x2 <- x[[z]][,"x"]
      y2 <- x[[z]][,"y"]
      
      # Return NULL for same label
      if(z == y){
        
        return(NA)
        
      }
      
      # X co-ordinates are overlapping
      if(min(x2) >= min(x1) & min(x2) <= max(x1) |
         max(x2) >= min(x1) & max(x2) <= max(x1)){
        
        # Y co-ordinates are also overlapping
        if(min(y2) >= min(y1) & min(y2) <= max(y1) |
           max(y2) >= min(y1) & max(y2) <= max(y1)){
          
          return(TRUE)
          
        }else{
          
          return(FALSE)
          
        }
        
      }
      
      # Non-overlapping x and y co-ordinates
      return(FALSE)
      
    }))
    
  })
  
  return(overlaps)
  
}
