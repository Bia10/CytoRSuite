#' Add boxed text labels to cyto_plot
#'
#' @param x object of class \code{"flowFrame"}.
#' @param gates object of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}},
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}},
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}, \code{"list"} or
#'   \code{\link[flowCore:filters-class]{filters}}.
#' @param ... additional method-specific arguments.
#'
#' @return add a boxed text label to cyto_plot.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @importFrom flowCore Subset parameters
#'
#' @seealso \code{\link{cyto_plot_label,flowFrame,rectangleGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,polygonGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,ellipsoidGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,list-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,filters-method}}
#'
#' @export
setGeneric(
  name = "cyto_plot_label",
  def = function(x, gates, ...) {
    standardGeneric("cyto_plot_label")
  }
)

#' Add boxed text labels to cyto_plot without gate
#'
#' \code{cyto_plot_label} takes on a \code{flowFrame} object, population name
#' \code{text}, \code{channels} and a gate object to construct a text label for
#' the plot with the population name and frequency. In the absence of a gate,
#' users can manually specify the label position using the \code{text_x} and
#' \code{text_y} arguments.
#'
#' @param x a \code{\link[flowCore:flowFrame-class]{flowFrame}} gated in the
#'   existing plot.
#' @param gates \code{NULL}.
#' @param trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param text character string to include in the label above the statistic
#'   (e.g. population name(s)).
#' @param stat indicates the type of statistic to include in the label, can be
#'   either code{"count"}, \code{"median"}, \code{"mean"}, \code{"mode"},
#'   \code{"geo mean"} or \code{"CV"}. \code{stat} is set to \code{"median"} by
#'   default. Statistics for fluorescent intensity are calculated for the entire
#'   distribution. Only count and percent statistics are supported for 2D plots.
#' @param text_x vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_y vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_font integer [1,2,3,4] passed to \code{text} to alter the font,
#'   set to \code{2} by default for a bold font.
#' @param text_size numeric character expansion used to control the size of the
#'   text in the labels, set to \code{0.8} by default. See \code{?text} for
#'   details.
#' @param text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param box_alpha numeric [0,1] controls the transparency of the background,
#'   set to \code{0.6} by default.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for mode
#'   calculation.
#'
#' @return add a boxed text label to cyto_plot.
#'
#' @importFrom flowCore Subset parameters
#' @importFrom graphics par
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot_label,flowFrame,polygonGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,ellipsoidGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,list-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,filters-method}}
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#'
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#'
#' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "T Cells",
#'   channels = c("Alexa Fluor 488-A", "Alexa Fluor 700-A")
#' )
#'
#' # Labels without gates - position using text_x and text_y
#' cyto_plot_label(getData(gs, "T Cells")[[4]],
#'   gates = NULL,
#'   channels = c("Alexa Fluor 488-A", "Alexa Fluor 700-A"),
#'   trans = trans,
#'   text = c("CD4 T Cells", "CD8 T Cells"),
#'   text_x = c(3.1, 1),
#'   text_y = c(-0.2, 3.2)
#' )
#' @export
setMethod(cyto_plot_label,
          signature = c("flowFrame", NULL),
          definition = function(x,
                                gates = NULL,
                                trans = NULL,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6,
                                density_smooth = 1.5) {
            
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(all(!is.na(stat))){
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Missing transList
            if (stat %in% c(
              "median",
              "mode",
              "mean",
              "geo mean",
              "CV"
            )) {
              if (is.null(cyto_trans_check(trans))) {
                stop(
                  paste("Supply transformList/transformerList to calculate", stat, ".")
                )
              }
            }
            
            # Stats not supported in 2D
            if (length(channels) == 2 &
                stat %in% c(
                  "mean",
                  "median",
                  "mode",
                  "geo mean",
                  "freq",
                  "CV"
                )) {
              stop("Only count is supported for 2D plots without gates.")
            }
            
            # Missing text
            if (all(is.na(text)) & !all(is.na(stat))) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistics
            if (!all(is.na(stat))) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(fr)
              } else if (stat == "median") {
                fr <- .getRawData(x = fr, trans)
                st <- median(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "mean") {
                fr <- .getRawData(x = fr, trans)
                st <- mean(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "mode") {
                fr <- .getRawData(x = fr, trans)
                d <- density(flowCore::exprs(fr)[, channels], adjust = density_smooth)
                st <- d$x[d$y == max(d$y)]
                st <- round(st, 2)
              } else if (stat == "geo mean") {
                st <- mean(flowCore::exprs(fr)[, channels])
                inv <- cyto_trans_check(trans, inverse = TRUE)
                st <- inv@transforms[[channels]]@f(st)
                st <- round(st, 2)
              } else if (stat == "CV"){
                fr <- .getRawData(x = fr, trans)
                fr.exprs <- exprs(fr)
                md <- median(fr.exprs[,channels])
                rSD <- median(abs(fr.exprs[,channels] - md))*1.4826
                st <- rSD/md
                st <- sprintf("%.2f %%", st*100)
              }
            }
            
            # Plot Limits
            xmin <- par("usr")[1]
            xmax <- par("usr")[2]
            ymin <- par("usr")[3]
            ymax <- par("usr")[4]
            
            # Label position - x - defaults to 3/4
            if (all(is.na(text_x))) {
              text_x <- xmin + (xmax - xmin) * 0.75
            }
            
            # Label position - y - defaults to 1/2
            if (all(is.na(text_y))) {
              text_y <- c(ymin + ymax) / 2
            }
            
            # Add labels
            if (!all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!all(is.na(text)) & all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }
)

#' Add boxed text labels to cyto_plot - rectangleGate Method
#'
#' \code{cyto_plot_label} takes on a \code{flowFrame} object, population name
#' \code{text}, \code{channels} and a gate object to construct a text label for
#' the plot with the population name and frequency.
#'
#' @param x a \code{\link[flowCore:flowFrame-class]{flowFrame}} gated in the
#'   existing plot.
#' @param gates an object of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}}.
#' @param trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param text character string to include in the label above the statistic
#'   (e.g. population name(s)).
#' @param stat indicates the type of statistic to include in the label, can be
#'   either \code{"freq"}, \code{"count"}, \code{"median"}, \code{"mean"},
#'   \code{"mode"}, \code{"geo mean"} or \code{"CV"}. \code{stat} is set to
#'   \code{"freq"} by default. Statistics for fluorescent intensity are
#'   calculated for the entire distribution. Only count and percent statistics
#'   are supported for 2D plots.
#' @param text_x vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_y vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_font integer [1,2,3,4] passed to \code{text} to alter the font,
#'   set to \code{2} by default for a bold font.
#' @param text_size numeric character expansion used to control the size of the
#'   text in the labels, set to \code{0.8} by default. See \code{?text} for
#'   details.
#' @param text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param box_alpha numeric [0,1] controls the transparency of the background,
#'   set to \code{0.6} by default.
#' @param density_smooth smoothing parameter passed to
#'   \code{\link[stats:density]{density}} to adjust kernel density for mode
#'   calculation.
#'
#' @return add a boxed text label to cyto_plot.
#'
#' @importFrom flowCore Subset parameters
#' @importFrom graphics par
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot_label,flowFrame,polygonGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,ellipsoidGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,list-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,filters-method}}
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#'
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#'
#' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "CD4 T Cells",
#'   channels = "7-AAD-A"
#' )
#'
#' # CD69+ CD4 T Cells gate
#' gt <- getGate(gs, "CD69+ CD4 T Cells")[[1]]
#' cyto_plot_gate(gt,
#'   channels = "7-AAD-A"
#' )
#'
#' # Labels
#' cyto_plot_label(getData(gs, "CD4 T Cells")[[4]],
#'   gates = gt,
#'   trans = trans,
#'   channels = "7-AAD-A",
#'   text = c("CD69+"),
#'   stat = "freq",
#'   text_col = "blue"
#' )
#' @export
setMethod(cyto_plot_label,
          signature = c("flowFrame", "rectangleGate"),
          definition = function(x,
                                gates = NULL,
                                trans = NULL,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6,
                                density_smooth = 1.5) {
            
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(all(!is.na(stat))){
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Only count and percent supported in 2D
            if (length(channels) == 2 & !stat %in% c("count", "freq")) {
              stop("Only count and percent statistics are supported in 2D plots.")
            }
            
            # Missing transList
            if (stat %in% c("median", "mode", "mean", "geo mean")) {
              if (is.null(cyto_trans_check(trans))) {
                stop(
                  paste("Supply transformList/transformerList to calculate", stat, ".")
                )
              }
            }
            
            # 2D gate in 1D plot
            if (length(channels) == 1 & length(parameters(gates)) == 2) {
              gates <- gates[channels]
            }
            
            # Missing text
            if (all(is.na(text)) & !all(is.na(stat))) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistics
            if (!all(is.na(stat))) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(flowCore::Subset(fr, gates))
              } else if (stat == "freq") {
                
                # Total events
                events <- BiocGenerics::nrow(fr)
                
                # Population events - percentages
                cnt <- BiocGenerics::nrow(flowCore::Subset(fr, gates))
                prcnt <- round(cnt / events, 4)
                st <- sprintf("%.2f %%", 100 * prcnt)
              } else if (stat == "mean") {
                fr <- .getRawData(x = fr, trans)
                st <- mean(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "median") {
                fr <- .getRawData(x = fr, trans)
                st <- median(flowCore::exprs(fr)[, channels])
                st <- round(st, 2)
              } else if (stat == "mode") {
                fr <- .getRawData(x = fr, trans)
                d <- density(flowCore::exprs(fr)[, channels], adjust = density_smooth)
                st <- d$x[d$y == max(d$y)]
                st <- round(st, 2)
              } else if (stat == "geo mean") {
                st <- mean(flowCore::exprs(fr)[, channels])
                inv <- cyto_trans_check(trans, inverse = TRUE)
                st <- inv@transforms[[channels]]@f(st)
                st <- round(st, 2)
              } else if (stat == "CV"){
                fr <- .getRawData(x = fr, trans)
                fr.exprs <- exprs(fr)
                md <- median(fr.exprs[,channels])
                rSD <- median(abs(fr.exprs[,channels] - md))*1.4826
                st <- rSD/md
                st <- sprintf("%.2f %%", st*100)
              }
            }
            
            # 1D gate plotted in 2D
            if (length(channels) == 2 & length(parameters(gates)) == 1) {
              rg <- matrix(c(as.numeric(gates@min), as.numeric(gates@max), -Inf, Inf),
                           ncol = 2, nrow = 2
              )
              colnames(rg) <- c(
                as.vector(parameters(gates)),
                channels[!channels == as.vector(parameters(gates))]
              )
              rownames(rg) <- c("min", "max")
              gates <- rectangleGate(.gate = rg)
            }
            
            # Gate channels
            chans <- as.vector(parameters(gates))
            
            # Plot limits
            xmin <- par("usr")[1]
            xmax <- par("usr")[2]
            ymin <- par("usr")[3]
            ymax <- par("usr")[4]
            
            # 1D gate supplied
            if (length(chans) == 1) {
              if (length(channels) == 1) {
                if (!channels == chans) {
                  stop("Supplied channel does not match that of the supplied gate.")
                } else if (channels == chans) {
                  if (all(is.na(text_x))) {
                    xmin <- gates@min
                    xmax <- gates@max
                    
                    if (is.infinite(xmin)) {
                      xmin <- par("usr")[1]
                    }
                    if (is.infinite(xmax)) {
                      xmax <- par("usr")[2]
                    }
                  }
                }
              } else if (length(channels) == 2) {
                if (!chans %in% channels) {
                  stop("Supplied channels do not match that of the supplied gate.")
                } else if (chans %in% channels) {
                  if (all(is.na(text_x))) {
                    xmin <- gates@min[channels[1]]
                    xmax <- gates@max[channels[1]]
                    
                    if (is.infinite(xmin)) {
                      xmin <- par("usr")[1]
                    }
                    
                    if (is.infinite(xmax)) {
                      xmax <- par("usr")[2]
                    }
                  }
                  
                  if (all(is.na(text_y))) {
                    ymin <- gates@min[channels[2]]
                    ymax <- gates@max[channels[2]]
                    
                    if (is.infinite(ymin)) {
                      ymin <- par("usr")[3]
                    }
                    
                    if (is.infinite(ymax)) {
                      ymax <- par("usr")[4]
                    }
                  }
                }
              }
              
              # 2D gate supplied
            } else if (length(chans) == 2) {
              if (!all(chans %in% channels)) {
                stop("Supplied channels do not match that of the supplied gate.")
              } else if (all(chans %in% channels)) {
                if (all(is.na(text_x))) {
                  xmin <- gates@min[channels[1]]
                  xmax <- gates@max[channels[1]]
                  
                  if (is.infinite(xmin)) {
                    xmin <- par("usr")[1]
                  }
                  
                  if (is.infinite(xmax)) {
                    xmax <- par("usr")[2]
                  }
                }
                
                if (all(is.na(text_y))) {
                  ymin <- gates@min[channels[2]]
                  ymax <- gates@max[channels[2]]
                  
                  if (is.infinite(ymin)) {
                    ymin <- par("usr")[3]
                  }
                  
                  if (is.infinite(ymax)) {
                    ymax <- par("usr")[4]
                  }
                }
              }
            }
            
            # Label position - x - defaults to 3/4
            if (all(is.na(text_x))) {
              text_x <- c(xmin + xmax) / 2
            }
            
            # Label position - y - defaults to 1/2
            if (all(is.na(text_y))) {
              text_y <- c(ymin + ymax) / 2
            }
            
            # Add labels
            if (!all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!all(is.na(text)) & all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }
)

#' Add boxed text labels to cyto_plot - polygonGate Method
#'
#' \code{cyto_plot_label} takes on a \code{flowFrame} object, population name
#' \code{text}, \code{channels} and a gate object to construct a text label for
#' the plot with the population name and frequency.
#'
#' @param x a \code{\link[flowCore:flowFrame-class]{flowFrame}} gated in the
#'   existing plot.
#' @param gates an object of class
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}}.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param text the name of the gated population, set to NA by default to only
#'   include percent in labels.
#' @param stat indicates the type of statistic to include in the label, can be
#'   either \code{"freq"} or \code{"count"}. \code{stat} is set to
#'   \code{"freq"} by default.
#' @param text_x vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_y vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_font integer [1,2,3,4] passed to \code{text} to alter the font,
#'   set to \code{2} by default for a bold font.
#' @param text_size numeric character expansion used to control the size of the
#'   text in the labels, set to \code{0.8} by default. See \code{?text} for
#'   details.
#' @param text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param box_alpha numeric [0,1] controls the transparency of the background,
#'   set to \code{0.6} by default.
#'
#' @return add a boxed text label to cyto_plot.
#'
#' @importFrom flowCore Subset parameters
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot_label,flowFrame,rectangleGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,ellipsoidGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,list-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,filters-method}}
#'
#' @examples
#' library(CytoRSuiteData)
#' 
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#' 
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#' 
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#' 
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#' 
#' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "root",
#'   channels = c("FSC-A", "SSC-A")
#' )
#' 
#' # Cells gate
#' gt <- getGate(gs, "Cells")[[1]]
#' cyto_plot_gate(gt,
#'   channels = c("FSC-A", "SSC-A")
#' )
#' 
#' # Labels
#' cyto_plot_label(getData(gs, "root")[[4]],
#'   gates = gt,
#'   trans = trans,
#'   channels = c("FSC-A", "SSC-A"),
#'   text = "Cells",
#'   stat = "freq",
#'   text_col = "magenta",
#'   text_size = 1.2
#' )
#' @export
setMethod(cyto_plot_label,
          signature = c("flowFrame", "polygonGate"),
          definition = function(x,
                                gates,
                                channels,
                                trans = NULL,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(all(!is.na(stat))){
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Only count and percent supported
            if (!stat %in% c("count", "freq")) {
              stop("Only 'count' and 'percent' are supported for gated 2D plots.")
            }
            
            # Missing text
            if (all(is.na(text)) & !all(is.na(stat))) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistic
            if (!all(is.na(stat))) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(flowCore::Subset(fr, gates))
              } else if (stat == "freq") {
                # Total events
                events <- nrow(fr)
                
                # Population events - percentages
                cnt <- BiocGenerics::nrow(flowCore::Subset(fr, gates))
                prcnt <- round(cnt / events, 4)
                st <- sprintf("%.2f %%", 100 * prcnt)
              }
            }
            
            # Check supplied channels & gate channels
            chans <- parameters(gates)
            
            # Check gate parameters against channels
            if (!all(chans %in% channels)) {
              stop("Supplied channels do not match that of the supplied gate.")
            }
            
            # Label position - x
            if (all(is.na(text_x))) {
              text_x <- sum(gates@boundaries[, channels[1]]) / nrow(gates@boundaries)
            }
            
            # Label position - y
            if (all(is.na(text_y))) {
              text_y <- sum(gates@boundaries[, channels[2]]) / nrow(gates@boundaries)
            }
            
            # Add labels
            if (!all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!all(is.na(text)) & all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }
)

#' Add boxed text labels to cyto_plot - ellipsoidGate Method
#'
#' \code{cyto_plot_label} takes on a \code{flowFrame} object, population name
#' \code{text}, \code{channels} and a gate object to construct a text label for
#' the plot with the population name and frequency.
#'
#' @param x a \code{\link[flowCore:flowFrame-class]{flowFrame}} gated in the
#'   existing plot.
#' @param gates an object of class
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param text the name of the gated population, set to NA by default to only
#'   include percent in labels.
#' @param stat indicates the type of statistic to include in the label, can be
#'   either \code{"freq"} or \code{"count"}. \code{stat} is set to
#'   \code{"freq"} by default.
#' @param text_x vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_y vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_font integer [1,2,3,4] passed to \code{text} to alter the font,
#'   set to \code{2} by default for a bold font.
#' @param text_size numeric character expansion used to control the size of the
#'   text in the labels, set to \code{0.8} by default. See \code{?text} for
#'   details.
#' @param text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param box_alpha numeric [0,1] controls the transparency of the background,
#'   set to \code{0.6} by default.
#'
#' @return add a boxed text label to cyto_plot.
#'
#' @importFrom flowCore Subset parameters
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot_label,flowFrame,rectangleGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,polygonGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,list-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,filters-method}}
#'
#' @examples
#' library(CytoRSuiteData)
#' 
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#' 
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#' 
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#' 
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#' 
#' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "Live Cells",
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#' 
#' # T Cells gate
#' gt <- getGate(gs, "T Cells")[[1]]
#' cyto_plot_gate(gt,
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#' 
#' # Labels
#' cyto_plot_label(getData(gs, "Live Cells")[[4]],
#'   gates = gt,
#'   trans = trans,
#'   channels = c("APC-Cy7-A", "PE-A"),
#'   text = "T Cells",
#'   stat = "count",
#'   text_col = "magenta",
#'   text_size = 1.2,
#'   box_alpha = 1
#' )
#' @export
setMethod(cyto_plot_label,
          signature = c("flowFrame", "ellipsoidGate"),
          definition = function(x,
                                gates,
                                channels,
                                trans = NULL,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Assign x to fr
            fr <- x
            
            # Check statistic
            if(all(!is.na(stat))){
              stat <- .cyto_stat_check(stat)
            }
            
            # Channels needed to position label
            if (missing(channels)) {
              stop("Supply channel/marker(s) to contruct the plot.")
            }
            
            # Only count and percent supported
            if (!stat %in% c("count", "freq")) {
              stop("Only 'count' and 'percent' are supported for gated 2D plots.")
            }
            
            # Missing text
            if (all(is.na(text)) & !all(is.na(stat))) {
              message(
                paste("No text supplied for labels - labels will show", stat, "only.")
              )
            }
            
            # Calculate statistic
            if (!all(is.na(stat))) {
              if (stat == "count") {
                st <- BiocGenerics::nrow(flowCore::Subset(fr, gates))
              } else if (stat == "freq") {
                # Total events
                events <- nrow(fr)
                
                # Population events - percentages
                cnt <- BiocGenerics::nrow(flowCore::Subset(fr, gates))
                prcnt <- round(cnt / events, 4)
                st <- sprintf("%.2f %%", 100 * prcnt)
              }
            }
            
            # Check supplied channels & gate channels
            chans <- parameters(gates)
            
            # Check gate parameters against channels
            if (!all(chans %in% channels)) {
              stop("Supplied channels do not match that of the supplied gate.")
            }
            
            # Label position - x
            if (all(is.na(text_x))) {
              text_x <- gates@mean[channels[1]]
            }
            
            # Label position - y
            if (all(is.na(text_y))) {
              text_y <- gates@mean[channels[2]]
            }
            
            # Add labels
            if (!all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = paste(text, st, sep = "\n"),
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (!all(is.na(text)) & all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = text,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            } else if (all(is.na(text)) & !all(is.na(stat))) {
              .boxed.labels(
                x = text_x,
                y = text_y,
                labels = st,
                border = FALSE,
                font = text_font,
                col = text_col,
                alpha.bg = box_alpha,
                cex = text_size
              )
            }
          }
)

#' Add boxed text labels to cyto_plot - list Method
#'
#' \code{cyto_plot_label} takes on a \code{flowFrame} object, population name
#' \code{text}, \code{channels} and a gate object to construct a text label for
#' the plot with the population name and frequency.
#'
#' @param x a \code{\link[flowCore:flowFrame-class]{flowFrame}} gated in the
#'   existing plot.
#' @param gates an object of class \code{"list"} containing objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}},
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}} or
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}.
#' @param trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param text the name of the gated population, set to NA by default to only
#'   include percent in labels.
#' @param stat indicates the type of statistic to include in the label, can be
#'   either \code{"freq"}, \code{"count"}, \code{"median"}, \code{"mean"},
#'   \code{"mode"}, \code{"geo mean"} or \code{"CV"}. \code{stat} is set to
#'   \code{"freq"} by default. Statistics for fluorescent intensity are
#'   calculated for the entire distribution. Only count and percent statistics
#'   are supported for 2D plots.
#' @param text_x vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_y vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_font integer [1,2,3,4] passed to \code{text} to alter the font,
#'   set to \code{2} by default for a bold font.
#' @param text_size numeric character expansion used to control the size of the
#'   text in the labels, set to \code{0.8} by default. See \code{?text} for
#'   details.
#' @param text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param box_alpha numeric [0,1] controls the transparency of the background,
#'   set to \code{0.6} by default.
#'
#' @return add a boxed text label to cyto_plot.
#'
#' @importFrom flowCore Subset parameters
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot_label,flowFrame,rectangleGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,polygonGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,ellipsoidGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,filters-method}}
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#'
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#'
#' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "Live Cells",
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#'
#' # T Cells & Dendritic Cells gates
#' gts <- list(getGate(gs, "T Cells")[[1]], getGate(gs, "Dendritic Cells")[[1]])
#' cyto_plot_gate(gts,
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#'
#' # Labels
#' cyto_plot_label(getData(gs, "Live Cells")[[4]],
#'   gates = gts,
#'   trans = trans,
#'   channels = c("APC-Cy7-A", "PE-A"),
#'   text = c("T Cells", "Dendritic Cells"),
#'   stat = "count",
#'   text_col = c("magenta", "purple"),
#'   text_size = 1.2,
#'   box_alpha = 1
#' )
#' @export
setMethod(cyto_plot_label,
          signature = c("flowFrame", "list"),
          definition = function(x,
                                gates,
                                trans = NULL,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Convert filters object in list to list of gates
            gates <- unlist(gates)
            
            # Get adjusted label coords to prevent overlap
            coords <- .cyto_plot_label_offset(x,
                                              gates,
                                              channels,
                                              text,
                                              stat,
                                              text_size)

            # Replace x coords if text_x is NA
            if(all(is.na(text_x))){
              text_x <- coords[["x"]]
            }
            
            # Replace y coords if text_y is NA
            if(all(is.na(text_y))){
              text_y <- coords[["y"]]
            }
            
            # Make calls to cyto_plot_label
            invisible(
              mapply(
                function(gate,
                         text,
                         stat,
                         text_x,
                         text_y,
                         text_font,
                         text_col,
                         text_size,
                         box_alpha) {
                  cyto_plot_label(
                    x = x,
                    trans = trans,
                    gates = gate,
                    channels = channels,
                    text = text,
                    stat = stat,
                    text_x = text_x,
                    text_y = text_y,
                    text_font = text_font,
                    text_col = text_col,
                    text_size = text_size,
                    box_alpha = box_alpha
                  )
                }, gates,
                text, 
                stat,
                text_x,
                text_y,
                text_font,
                text_col,
                text_size,
                box_alpha
              )
            )
          }
)

#' Add boxed text labels to cyto_plot - filters Method
#'
#' \code{cyto_plot_label} takes on a \code{flowFrame} object, population name
#' \code{text}, \code{channels} and a gate object to construct a text label for
#' the plot with the population name and frequency.
#'
#' @param x a \code{\link[flowCore:flowFrame-class]{flowFrame}} gated in the
#'   existing plot.
#' @param gates an object of class \code{\link[flowCore:filters-class]{filters}}
#'   containing objects of class
#'   \code{\link[flowCore:rectangleGate-class]{rectangleGate}},
#'   \code{\link[flowCore:polygonGate-class]{polygonGate}} or
#'   \code{\link[flowCore:ellipsoidGate-class]{ellipsoidGate}}.
#' @param trans object of class
#'   \code{\link[flowCore:transformList-class]{transformList}} or
#'   \code{\link[flowWorkspace]{transformerList}} generated by
#'   \code{\link[flowCore:logicleTransform]{estimateLogicle}} which was used to
#'   transform the fluorescent channels of the supplied flowFrame.
#' @param channels a vector indicating the fluorescent channel(s) to be used for
#'   gating.
#' @param text the name of the gated population, set to NA by default to only
#'   include percent in labels.
#' @param stat indicates the type of statistic to include in the label, can be
#'   either \code{"freq"}, \code{"count"}, \code{"median"}, \code{"mean"},
#'   \code{"mode"}, \code{"geo mean"} or\code{"CV"}. \code{stat} is set to
#'   \code{"freq"} by default. Statistics for fluorescent intensity are
#'   calculated for the entire distribution. Only count and percent statistics
#'   are supported for 2D plots.
#' @param text_x vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_y vector containing the x co-ordinates for the plot labels. Set
#'   to \code{NULL} by default to place labels in the center of the gates.
#' @param text_font integer [1,2,3,4] passed to \code{text} to alter the font,
#'   set to \code{2} by default for a bold font.
#' @param text_size numeric character expansion used to control the size of the
#'   text in the labels, set to \code{0.8} by default. See \code{?text} for
#'   details.
#' @param text_col specify text colour in label for each gate, defaults to
#'   \code{"black"} for all gates.
#' @param box_alpha numeric [0,1] controls the transparency of the background,
#'   set to \code{0.6} by default.
#'
#' @return add a boxed text label to cyto_plot.
#'
#' @importFrom flowCore Subset parameters
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @seealso \code{\link{cyto_plot_label,flowFrame,rectangleGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,polygonGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,ellipsoidGate-method}}
#' @seealso \code{\link{cyto_plot_label,flowFrame,list-method}}
#'
#' @examples
#' library(CytoRSuiteData)
#'
#' # Load in samples
#' fs <- Activation
#' gs <- GatingSet(fs)
#'
#' # Apply compensation
#' gs <- compensate(gs, fs[[1]]@description$SPILL)
#'
#' # Transform fluorescent channels
#' trans <- estimateLogicle(gs[[4]], cyto_fluor_channels(fs))
#' gs <- transform(gs, trans)
#'
#' # Gate using gate_draw
#' gating(Activation_gatingTemplate, gs)
#'
#' # Plot
#' cyto_plot(gs[[4]],
#'   parent = "Live Cells",
#'   channels = c("APC-Cy7-A", "PE-A")
#' )
#'
#' # T Cells & Dendritic Cells gates
#' gts <- filters(list(getGate(gs, "T Cells")[[1]], 
#' getGate(gs, "Dendritic Cells")[[1]]))
#' cyto_plot_gate(gts,
#'   channels = c("APC-Cy7-A", "PE-A"),
#'   gate_line_col = c("red", "black")
#' )
#'
#' # Labels
#' cyto_plot_label(getData(gs, "Live Cells")[[4]],
#'   gates = gts,
#'   trans = trans,
#'   channels = c("APC-Cy7-A", "PE-A"),
#'   text = c("T Cells", "Dendritic Cells"),
#'   stat = "freq",
#'   text_col = c("green4", "purple"),
#'   text_size = 1.2,
#'   box_alpha = 1
#' )
#' @export
setMethod(cyto_plot_label,
          signature = c("flowFrame", "filters"),
          definition = function(x,
                                gates,
                                trans = NULL,
                                channels,
                                text = NA,
                                stat = NA,
                                text_x = NA,
                                text_y = NA,
                                text_font = 2,
                                text_size = 0.8,
                                text_col = "black",
                                box_alpha = 0.6) {
            
            # Convert gates to a list of gates
            gates <- unlist(gates)
            
            # Make calls to cyto_plot_label list method
            cyto_plot_label(
              x = x,
              trans = trans,
              gates = gates,
              channels = channels,
              text = text,
              stat = stat,
              text_x = text_x,
              text_y = text_y,
              text_font = text_font,
              text_col = text_col,
              text_size = text_size,
              box_alpha = box_alpha
            )
            
    }
)

#' Dimensions of Labels
#' 
#' @param label_text character string to include in label.
#' 
#' @importFrom graphics strwidth strheight
#' 
#' @return upper left and bottom right x and y co-ordinates of labels
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @noRd
.cyto_plot_label_coords <- function(label_box_x,
                               label_box_y = NA,
                               label_text,
                               label_stat = NA,
                               bg = ifelse(match(par("bg"), "transparent", 0),
                                           "white", par("bg")
                               ),
                               border = NA,
                               xpad = 1.2,
                               ypad = 1.2,
                               label_text_size = 1,
                               adj = 0.5,
                               alpha.bg = 0.5, ...){
  
  border <- NA
  if(all(is.na(label_box_y))){
    label_box_y <- label_box_x
  }
  box.adj <- adj + (xpad - 1) * label_text_size * (0.5 - adj)
  
  # Rectangle widths
  lwidths <- strwidth(label_text)
  rwidths <- lwidths * (1 - box.adj)
  lwidths <- lwidths * box.adj
  bheights <- theights <- strheight(label_text) * 0.5

  # Rectangle co-ordinates
  xr <- label_box_x - lwidths * xpad
  xl <- label_box_x + lwidths * xpad
  
  # y co-ordinates must make space for label_stat
  if(is.na(label_stat)){
    
    yb <- label_box_y - bheights * ypad
    yt <- label_box_y + theights * ypad
    
  }else {
    
    yb <- label_box_y - bheights * ypad * 2
    yt <- label_box_y + theights * ypad * 2
  }
  
  # Return top left then bottom right co-ordinates
  coords <- matrix(c(min(c(xl,xr)),
                     max(c(yb,yt)),
                     max(c(xl,xr)),
                     min(c(yb,yt))),
                   ncol = 2,
                   byrow = TRUE)
  colnames(coords) <- c("x","y")
  
  return(coords)
  
}

#' Position Labels to Prevent Overlap
#'
#' @param x list of gate objects to be labelled.
#' @param channels names of channel(s) used to construct the plot.
#' @param label_text vector of character strings to use in labels.
#' @param label_text_size vector of integers for character expansion.
#'
#' @return list containing adjusted x and y coordinates for labels if any
#'   overlap is detected.
#'
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#'
#' @noRd
.cyto_plot_label_offset <- function(fr,
                                    x, 
                                    channels,
                                    label_text,
                                    label_stat,
                                    label_text_size) {
  
  # Invalid gate objects
  if(!inherits(x, "list")){
    stop("'x' should be a list of gate objects.")
  }
  
  # Assign x to gts
  gts <- x
  
  # Valid gate objects
  typs <- c("filters","rectangleGate","polygonGate","ellipsoidGate")
  
  # Convert gate object to list of gates
  if(inherits(gts,"list")){
    if(!all(unlist(lapply(gts, "class")) %in% typs)){
      stop("'x' does not contain a list of valid gate objects.")
    }
  }
  
  # Plot limits
  xmin <- par("usr")[1]
  xmax <- par("usr")[2]
  ymin <- par("usr")[3]
  ymax <- par("usr")[4]
  
  # Co-ordinates for gate centers
  coords <- lapply(gts, function(gt){
    
    if(inherits(gt, "rectangleGate")){
      
      # Gate channel(s)
      chans <- parameters(gt)
      
      if(length(channels) == 1 & length(chans) == 1){
        
        xmin <- gt@min
        xmax <- gt@max
        ymin <- ymin
        ymax <- ymax
        
      }else if(length(channels) == 1 & length(chans) == 2){
        
        xmin <- gt@min[channels[1]]
        xmax <- gt@max[channels[1]]
        ymin <- ymin
        ymax <- ymax
        
      }else if(length(channels) == 2 & length(chans) == 1){
        
        # Gate has xcoords
        if(chans == channels[1]){
          
          xmin <- gt@min
          xmax <- gt@max
          ymin <- ymin
          ymax <- ymax
          
        # Gate has ycoords
        }else if(chans == channels[2]){
          
          xmin <- xmin
          xmax <- xmax
          ymin <- gt@min
          ymax <- gt@max
          
        }
        
      }else if(length(channels) == 2 & length(chans) == 2){
        
        xmin <- gt@min[channels[1]]
        xmax <- gt@max[channels[1]]
        ymin <- gt@min[channels[2]]
        ymax <- gt@max[channels[2]]
        
      }
      coords <- c((xmin+xmax)/2, (ymin+ymax)/2)
      
    }else if(inherits(gt, "polygonGate")){
      
      coords <- c(sum(gt@boundaries[, channels[1]]) / nrow(gt@boundaries),
                  sum(gt@boundaries[, channels[2]]) / nrow(gt@boundaries))
      
    }else if(inherits(gt, "ellipsoidGate")){
      
      coords <- c(gt@mean[channels[1]], gt@mean[channels[2]])
      
    }
    return(coords)
    
  })
  coords <- do.call("rbind", coords)
  colnames(coords) <- c("x", "y")
  
  # Calculate label co-ordinates
  label_coords <- lapply(seq_len(length(gts)), function(x){
    
    .cyto_plot_label_coords(label_box_x = coords[,"x"][x],
                       label_box_y = coords[,"y"][x],
                       label_text = label_text[x], 
                       label_stat = label_stat[x],
                       label_text_size = label_text_size[x])
    
  })
  
  # Some labels will be overlapping
  if(any(na.omit(unlist(.cyto_plot_label_overlap(label_coords))))){
    
    # Split y axis into n labels based on label height
    label_height <- abs(label_coords[[1]][,"y"][2] - label_coords[[1]][,"y"][1])
    
    # Number of label options
    label_y_levels <- floor((ymax - ymin)/ label_height)
    
    # Options for y positioning
    label_y_options <- seq(ymin, ymax, length.out = label_y_levels) + 
      0.5 * label_height
    label_y_options <- label_y_options[label_y_options < ymax]
    
    # Run through each label to see which label_y_option is closest
    label_y_closest <- unlist(lapply(seq_len(length(gts)), function(x){
      label_y_options[which.min(abs(label_y_options - coords[,"y"][x]))]
    }))
  
    # Run through each label and adjust labels which will be overlapping
    label_y_taken <- c()
    lapply(seq_len(length(gts)), function(x){
      
      # First gate gets its label_y_closest position
      if(x == 1){
       
        # Update coords with label_y_closest position
        coords[,"y"][x] <<- label_y_closest[x]
        label_y_taken[x] <<- coords[,"y"][x]
        
      # Subsequent gates check to see any close labels have already taken the 
      # desired label_y_closest
      }else if(x > 1){
        
        # Other labels don't share same label_y_closest
        if(length(which(label_y_closest == label_y_closest[x])) == 1){
        
          # Update coords with label_y_closest position
          coords[,"y"][x] <<- label_y_closest[x]
          label_y_taken[x] <<- coords[,"y"][x]
          
        # Other labels share same label_y_closest  
        }else if(length(which(label_y_closest == label_y_closest[x])) > 1){
          
          # Other labels want the same label_y_closest
          label_y_same_closest <- which(label_y_closest == label_y_closest[x])
          
          # Any preivous labels which share label_y_closest?
          if(any(label_y_same_closest < x)){
            
            # Previous label used label_y_closest
            previous_y_closest <- label_y_same_closest[label_y_same_closest < x]

            # Coords of current label and previous with shared label_y_closest
            # Test for proximity
            test_coords <- label_coords[c(x,previous_y_closest)]
            
            # Previous label close to x, remove option and choose again 
            if(any(na.omit(.cyto_plot_label_overlap(test_coords)[[1]]))) {
              
              close_previous <- previous_y_closest[which(
                .cyto_plot_label_overlap(test_coords)[[1]])-1]
              
              label_y_remove <- match(label_y_taken[close_previous], 
                                      label_y_options)

              label_y_options <- label_y_options[-label_y_remove]
              
            }
              
            # Update coords with label_y_closest position
            label_y_chosen <- which.min(abs(label_y_options - coords[,"y"][x]))
            coords[,"y"][x] <<- label_y_options[label_y_chosen]
            label_y_taken[x] <<- coords[,"y"][x]
            
          # No previous labels with same label_y_closest
          }else {
            
            # Update coords with label_y_closest position
            label_y_chosen <- which.min(abs(label_y_options - coords[,"y"][x]))
            coords[,"y"][x] <<- label_y_options[label_y_chosen]
            label_y_taken[x] <<- coords[,"y"][x]
            
          }
          
        }
        
      }
      
    })
    
  # No labels are overlapping
  }else {
    
    # Use gate centers for label positioning - no adjustment needed
    
  }
  
  # Return a list of adjusted label positions
  coords <- list(coords[,"x"], coords[,"y"])
  names(coords) <- c("x","y")
  
  return(coords)

}

#' Check if any cyto_plot labels overlap
#' 
#' @param x list containing the x and y coordinates defining rectangles of plot
#' labels
#' 
#' @return list of length x. Each element compares the label to all others and 
#' returns TRUE is any overlap is detected. NA is returned when comparing the
#' same label co-ordinates.
#' 
#' @author Dillon Hammill (Dillon.Hammill@anu.edu.au)
#' 
#' @noRd
.cyto_plot_label_overlap <- function(x) {
  
  # For each rectangle in x
  overlaps <- lapply(seq_len(length(x)), function(y){
    
    # Check if other rectangles overlap
    unlist(lapply(seq_len(length(x)), function(z){
      
      # Co-ordinates of reference label
      x1 <- x[[y]][,"x"]
      y1 <- x[[y]][,"y"]
        
      # Co-ordinates of comparison label
      x2 <- x[[z]][,"x"]
      y2 <- x[[z]][,"y"]
      
      # Return NULL for same label
      if(z == y){
        
        return(NA)
        
      }
      
      # X co-ordinates are overlapping
      if(min(x2) >= min(x1) & min(x2) <= max(x1) |
         max(x2) >= min(x1) & max(x2) <= max(x1)){
        
        # Y co-ordinates are also overlapping
        if(min(y2) >= min(y1) & min(y2) <= max(y1) |
           max(y2) >= min(y1) & max(y2) <= max(y1)){
          
          return(TRUE)
          
        }else{
          
          return(FALSE)
          
        }
        
      }
      
      # Y co-ordinates are overlapping
      if(min(y2) >= min(y1) & min(y2) <= max(y1) |
         max(y2) >= min(y1) & max(y2) <= max(y1)){
        
        # X co-ordinates are also overlapping
        if(min(x2) >= min(x1) & min(x2) <= max(x1) |
           max(x2) >= min(x1) & max(x2) <= max(x1)){
          
          return(TRUE)
          
        }else{
          
          return(FALSE)
          
        }
        
        
      }
      
      # Non-overlapping x and y co-ordinates
      return(FALSE)
      
    }))
    
  })
  
  return(overlaps)
  
}

