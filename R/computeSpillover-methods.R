#' Compute Spillover Matrix
#' 
#' Compute spillover matrix using single stain compensation controls and an unstained control.
#' 
#' @param x object of class \code{flowSet} or \code{GatingSet}.
#' 
#' @author Dillon Hammill, \email{Dillon.Hammill@anu.edu.au}
#' 
#' @references C. B. Bagwell \& E. G. Adams (1993). Fluorescence spectral overlap compensation for any number of flow cytometry parameters. in: Annals of the New York Academy of Sciences, 677:167-184.
#' 
#' @export
setGeneric(name="computeSpillover",
           def=function(x, ...){standardGeneric("computeSpillover")}
)

#' Caluclate Spillover Matrix Using Pre-gated Compensation Controls
#' 
#' @param x object of class \code{flowSet} containing pre-gated compensation single stain controls as well as an unstained control.
#' @param trans object of class \code{"transformList"} generated by \code{estimateLogicle} to transform fluorescent channels for gating.
#' @param pdfile \code{pData} csv file containing additional column \code{"channel"} indicating the fluorescent channel associated
#' with each sample. This channel should be set to \code{"Unstained"} for unstained controls.
#' @param spfile name of the output spillover csv file, set to \code{"Spillover Matrix.csv"} by default.
#' 
#' @return spillover matrix object and \code{"Spillover Matrix.csv"} file as side effect.
#' 
#' @importFrom flowCore transform
#' @export
setMethod(computeSpillover, signature = "flowSet", definition = function(x, trans = NULL, pdfile = NULL, spfile = "Spillover Matrix.csv", ...){
  
  fs <- x
  
  # Extract fluorescent channels
  channels <- getChannels(fs)
  
  # Select a fluorescent channel for each compensation control
  if(is.null(pdfile)){
    
    pData(fs)$channel <- paste(selectChannels(fs))
    write.csv(pData(fs), "Compensation Controls Channels.csv", row.names = FALSE)
    
  }else{
    
    pd <- read.csv(pdfile, header = TRUE, row.names = 1)
    pData(fs)$channel <- paste(pd$channel)
    
  }
  
  # Merge files for use with estimateLogicle
  fr <- as(fs, "flowFrame")
  
  # Apply logicle transformation for gating
  if(is.null(trans) | class(trans) != "transformList"){
    
    message("No transformList supplied to transfom channels prior to gating. All fluorescent channels will be transformed using the logicle transformation.")
    
    # Check if transformation has been applied using range of values
    if(!all(each_col(fs[[1]], range)[,channels][1,] >= -5 & each_col(fs[[1]], range)[,channels][2,] <= 5)){
      
      # Transformation has not been applied
      trans <- estimateLogicle(fr, channels)
      fs <- transform(fs, trans)
      
    }else{
      
      stop("Please provide transformList object used to transform the flowSet to the trans argument.")
      
    }
    
  }else if(!all(channels %in% names(trans))){
    
    # Not all fluorescent channels are listed in transformList
    message("Not all channels are transformed using this transformList - applying logicle transformation to remaining fluorescent channels.")
    
    # Check if transformation has been applied using range of values
    if(!all(each_col(fs[[1]], range)[,names(trans)][1,] >= -5 & each_col(fs[[1]], range)[,names(trans)][2,] <= 5)){
      
      # Get transformList for remaining channels
      chnls <- channels[-match(names(trans), channels)]
      trans <- c(trans, estimateLogicle(fr, chnls))
      
      # Transformation has not been applied
      fs <- transform(fs, trans)
      
    }
    
  }else if(all(channels %in% names(trans))){
    
    # Check if transformation has been applied using range of values
    if(!all(each_col(fs[[1]], range)[,channels][1,] >= -5 & each_col(fs[[1]], range)[,channels][2,] <= 5)){
      
      # Transformation has not been applied
      fs <- transform(fs, trans)
      
    }
    
  }
  
  # Extract unstained control based on selected channels in pData(fs)
  NIL <- fs[[match("Unstained", pData(fs)$channel)]]
  fs <- fs[-match("Unstained", pData(fs)$channel)]
  
  # Assign channel to each flowFrame to description slot called "channel"
  suppressWarnings(sapply(1:length(pData(fs)$channel), function(x){
    
    fs[[x]]@description$channel <- paste(pData(fs)$channel[x])
    
  }))
  
  # Gate positive populations
  pops <- fsApply(fs, function(fr){
    
    # Call drawGate on each flowFrame using interval gate on selected channel
    gt <- drawGate(x = fr, alias = paste(fr@description$channel,"+"), channels = fr@description$channel, gate_type = "interval", adjust = 1.5)
    fr <- Subset(fr, gt[[1]])
    
  }, simplify = TRUE)
  
  # Inverse logicle transformation
  inv <-  inverseLogicleTransform(trans)
  pops <- transform(pops, inv)
  NIL <- transform(NIL, inv)
  
  # Calculate MedFI for all channels for unstained control
  neg <- each_col(NIL, median)[channels]
  
  # Calculate MedFI for all channels for all stained controls
  pos <- fsApply(pops, each_col, median)[,channels]
  
  # Subtract background fluorescence
  signal <- sweep(pos, 2, neg)
  
  # Construct spillover matrix - only include values for which there is a control
  spill <- diag(x = 1, nrow = length(channels), ncol = length(channels))  
  colnames(spill) <- channels
  rownames(spill) <- channels
  
  # Normalise each row to stained channel
  for(i in 1:nrow(signal)){
    
    signal[i, ] <- signal[i, ]/signal[i, match(fs[[i]]@description$channel, colnames(spill))]
    
  } 
  
  # Insert values into appropriate rows
  rws <- match(pData(fs)$channel, rownames(spill))
  spill[rws,] <- signal
  
  write.csv(spill, spfile)
  return(spill)
  
})

#' Caluclate Spillover Matrix - GatingSet Method
#' 
#' @param x object of class \code{GatingSet} containing gated compensation single stain controls as well as an unstained control.
#' @param alias name of the gated population to use for downstream calculations, set to the last node of the GatingSet by default.
#' @param pdfile \code{pData} csv file containing additional column \code{"channel"} indicating the fluorescent channel associated
#' with each sample. This channel should be set to \code{"Unstained"} for unstained controls.
#' @param spfile name of the output spillover csv file, set to \code{"Spillover Matrix.csv"} by default.
#' 
#' @importFrom flowWorkspace getData
#' 
#' @return spillover matrix and \code{"Spillover Matrix.csv"} file.
#' 
#' @importFrom flowCore transform
#' @export
setMethod(computeSpillover, signature = "GatingSet", definition = function(x, alias = NULL, pdfile = NULL, spfile = "Spillover Matrix.csv", ...){
  
  gs <- x
  
  # Extract fluorescent channels
  channels <- getChannels(gs)
  
  # Select a fluorescent channel for each compensation control
  if(is.null(pdfile)){
    
    pData(gs)$channel <- paste(selectChannels(gs))
    write.csv(pData(gs), "Compensation Controls Channels.csv", row.names = FALSE)
    
  }else{
    
    pd <- read.csv(pdfile, header = TRUE, row.names = 1)
    pData(gs)$channel <- paste(pd$channel)
    
  }

  # Merge files for use with estimateLogicle
  fr <- as(fs, "flowFrame")
  fs.m <- flowSet(fr)
  gs.m <- GatingSet(fs.m)
  
  # Check if fluorescent channels have been transformed
  if(length(gs[[1]]@transformation) == 0){
    
    # Calculate transformation parameters using estimateLogicle
    trans <- estimateLogicle(gs.m[[1]], channels)
    gs <- transform(gs, trans)
    
  }else if(length(gs[[1]]@transformation) != 0){
    
    # Check which channels have been transformed
    chans <- names(gs@transformation[[1]])
    
    if(all(channels %in% chans)){
      
      # All fluorescent channels have been transformed
      
    }else{
      
      # Not all fluorescent channels are transformed - transform remaining channels
      # Which channels need transform? Use appropriate sample to get transform (indx of samples)
      chans <- names(gs@transformation[[1]])
      chans <- channels[is.na(match(channels,chans))]
      
      trans <- estimateLogicle(gs.m[[1]], chans)
      print(trans)
      gs <- transform(gs, trans)
      
    }
    
  }
  
  # Extract Population for Downstream Analyses
  if(!is.null(alias)){
    
    fs <- flowWorkspace::getData(gs, alias)
    
  }else if(is.null(alias)){
    
    fs <- flowWorkspace::getData(gs, getNodes(gs)[length(getNodes(gs))])
    
  }
  
  # Extract unstained control based on selected channels in pData(fs)
  NIL <- fs[[match("Unstained", pData(fs)$channel)]]
  fs <- fs[-match("Unstained", pData(fs)$channel)]
  
  # Assign channel to each flowFrame to description slot called "channel"
  suppressWarnings(sapply(1:length(pData(fs)$channel), function(x){
    
    fs[[x]]@description$channel <- paste(pData(fs)$channel[x])
    
  }))
  
  # Gate positive populations
  pops <- fsApply(fs, function(fr){
    
    # Call drawGate on each flowFrame using interval gate on selected channel
    gt <- drawGate(x = fr, alias = paste(fr@description$channel,"+"), channels = fr@description$channel, gate_type = "interval", adjust = 1.5)
    fr <- Subset(fr, gt[[1]])
    
  }, simplify = TRUE)
  
  # Inverse logicle transformation
  trans <- gs@transformation[[1]]
  inv <- transformList(names(trans), lapply(trans, `[[`, "inverse"))
  pops <- transform(pops, inv)
  NIL <- transform(NIL, inv)
  
  # Calculate MedFI for all channels for unstained control
  neg <- each_col(NIL, median)[channels]
  
  # Calculate MedFI for all channels for all stained controls
  pos <- fsApply(pops, each_col, median)[,channels]
  
  # Subtract background fluorescence
  signal <- sweep(pos, 2, neg)
  
  # Construct spillover matrix - only include values for which there is a control
  spill <- diag(x = 1, nrow = length(channels), ncol = length(channels))  
  colnames(spill) <- channels
  rownames(spill) <- channels
  
  # Normalise each row to stained channel
  for(i in 1:nrow(signal)){
    
    signal[i, ] <- signal[i, ]/signal[i, match(fs[[i]]@description$channel, colnames(spill))]
  
  } 
  
  # Insert values into appropriate rows
  rws <- match(pData(fs)$channel, rownames(spill))
  spill[rws,] <- signal
  
  write.csv(spill, spfile)
  return(spill)
  
})
